ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789

ace    bad    cat    dry    eve
away   bent   crow   dove   ends
attic  brand  crypt  dried  event
annoys baller camera diving ethics



~`!@#$%^&*()-_+=<>,./?;:'"[{
0123456789

In the future:

your toaster will be smarter than you.
Robots will take over the world, but they'll do it in style.
Augmented reality will let you pet virtual unicorns in your living room.
Quantum computing will allow you to calculate the meaning of life in seconds.
Blockchain will make your online shopping experience more secure than Fort Knox.
Cybersecurity will be so advanced, hackers will have to resort to using actual swords.
In the future, we'll all communicate through a universal language made up entirely of emojis.


MM-DD-YYYY (or MM.DD.YYYY -- MM/DD/YYYY)

06-04-2000
Christmas this year is 12/25/2023
02-22-2022
Humans first stepped on the moon July 20, 1969
10/31/99
A great movie came out on 02.16.1996
2022/12/23

dateRegEx = /\w*?\s?[0-3]?\d?\d?\d?[-\./\s][0-3]\d[-\./,\s]?[,\s]?\d{2}?\d?\d?/

--------------------------------------------------------------------------------------------------

 5 kyu  Regex Password Validation
You need to write regex that will validate a password to make sure it meets the following criteria:
At least six characters long
contains a lowercase letter
contains an uppercase letter
contains a digit
only contains alphanumeric characters (note that '_' is not alphanumeric)   

  /**  ^: Asserts the start of the string.
  (?=.*[a-z]): Requires at least one lowercase letter.
  (?=.*[A-Z]): Requires at least one uppercase letter.
  (?=.*\d): Requires at least one digit.
  [A-Za-z\d]{6,}: Matches alphanumeric characters (including both uppercase and lowercase letters) with a minimum length of 6.
  $: Asserts the end of the string. */

  const REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{6,}$/;
==================================================================================================

  Regex Password Validation
A regex that will validate a password to make sure it meets the following criteria:
At least six characters long
contains a lowercase letter
contains an uppercase letter
contains a digit
only contains alphanumeric characters (note that '_' is not alphanumeric) 

const REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{6,}$/;
const re = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?!.*[_])\w{6,}$/;

=========================================================================   regex with vars:

  const splitInParts = function (s, partLength) {
    const regex = new RegExp(`\\w{${partLength}}`, 'g');
    return s.match(regex).join(' ') + ' ' + s.slice(-s.length % partLength);
  };

  const splitInParts = (s, partLength) => s.match(new RegExp(`.{1,${partLength}}`, 'g')).join(' ');
  const splitInParts = (s, partLength) => s.replace(new RegExp(`(.{${partLength}})(?!$)`, 'g'), '$1 ');
  ================================================================================================

   const consecutive = (arr, a, b) => new RegExp(`${a},${b}|${b},${a}`).test(arr);
   console.log(consecutive([1, 6, 9, -3, 4, -78, 0], -3, 4));

    RegExp    ====================================================================================

Let's create our first regular expression, there are two ways:

var reg1=/abc/
var reg2=new RegExp("abc")
console.log(reg1,reg2)  //output: /abc/ /abc/

We can see that we have created regular expressions in two ways. The first method is direct writing, the second method uses the new keyword. Their results are the same, the only difference is that using the second methods can use variables. See examples of using variables:

var words=["abc","123","&##"];
for (var r of words){
  var reg=new RegExp(r)
  console.log(reg)
}
//output: 
/abc/
/123/
/&##/

The main part of the regular expression is like what we see: At the beginning is "/", the end is "/" too. The other option is flag, which is optional. Each option is a letter, they include: "g"(global match), "i"(ignore case), "m"(multiline match), "u"(unicode), "y"(sticky). They are attached to the tail of the regular expression.

We often use the options: "g" and "i". "g" can let us in a string matching to multiple results; "i" can let us at the same time matching to the upper case and lower case letters.

In this lesson we only learn the most basic usage of regular expressions: only the characters that are explicitly pointed out. At the same time, we need to review some of the previous string methods (which can use regular expressions). Here are some examples:

    search()

    //example for search()
    var str="abcde";
    console.log( str.search(/abc/) )  //output: 0
    console.log( str.search("abc") )  //output: 0
    console.log( str.search(/cde/) )  //output: 2
    console.log( str.search("cde") )  //output: 2

    We can see that using a basic regular expression and using a string is the same. But in some cases they will have different results:

    //example for search()
    var str="ABCDEabcde";
    console.log( str.search(/abc/) )   //output: 5
    console.log( str.search(/abc/i) )  //output: 0
    console.log( str.search(/cde/) )   //output: 7
    console.log( str.search(/cde/ig) ) //output: 2

    Using the "i" flag, the search() method matches the "ABC" and "CDE". The search() method does not support "g" flag (global matching), it only returns the position of the first match string.

    replace(). It allows the use of "i" and "g":

//example for replace()
var str="Hello World! Hello CodeWars!"
console.log( str.replace(/world/,"javascript") )  
//output: Hello World! Hello CodeWars!   
//(There is no match to the string, so nothing is replaced.)

console.log( str.replace(/world/i,"Javascript") )  
//output: Hello Javascript! Hello CodeWars!   
//(Using "i" flag to match "World" and replace it by "Javascript")

console.log( str.replace(/Hello/g,"I love") )  
//output: I love World! I love CodeWars!   
//(Using "g" flag to match two "Hello" and replace it by "I love")

    split(). It uses the "g" option by default, regardless of whether you specify it or not.

    //example for split()
    var str="ababaBa"
    console.log( str.split(/b/) )   //output: [ 'a', 'a', 'aBa' ]
    console.log( str.split(/b/g) )  //output: [ 'a', 'a', 'aBa' ]
    console.log( str.split(/b/i) )  //output: [ 'a', 'a', 'a', 'a' ]

    match(). We have not learned this method before, because its parameter is a regular expression. Its result is an array that includes the matching results of regular expressions. We mainly use this method in the example to demonstrate the effect of regular expressions. See an example:

    //example for match()
    var str="ABABCDEababcde";
    console.log(str.match(/a/))  //output: [ 'a', index: 7, input: 'ABABCDEababcde' ]
    console.log(str.match(/a/i)) //output: [ 'A', index: 0, input: 'ABABCDEababcde' ]
    console.log(str.match(/a/ig))//output: [ 'A', 'A', 'a', 'a' ]
    console.log(str.match(/ab/)) //output: [ 'ab', index: 7, input: 'ABABCDEababcde' ]
    console.log(str.match(/ab/i))//output: [ 'AB', index: 0, input: 'ABABCDEababcde' ]
    console.log(str.match(/ab/ig))//output: [ 'AB', 'AB', 'ab', 'ab' ]
    console.log(str.match(/xyz/)) //output: null

    We can see: When the matching result is more than one, the output is an array of strings that contain all the matching results; When the matching result is one, the output is a list containing the matching string, the matching index and the original string. If there is no match result, the output is null.

We often use match() or replace() or split() to count the number of characters in a string:

//example for match()
function count1(str,char){
  return str.match(new RegExp(char,"g")).length
}
function count2(str,char){
  return str.length-str.replace(new RegExp(char,"g"),"").length;
}
function count3(str,char){
  return str.split(char).length-1;
}
console.log(count1("aaaaa","a"))  //output: 5
console.log(count2("aaaaa","a"))  //output: 5
console.log(count3("aaaaa","a"))  //output: 5
console.log(count1("aaaaa","b"))  
//output: TypeError: Cannot read property 'length' of null
console.log(count2("aaaaa","b"))  //output: 0
console.log(count3("aaaaa","b"))  //output: 0

The three methods can achieve the same effect. We note that in the second time using match(), we got a "TypeError". Because the match() does not match to the string, its result is null, null does not have the length attribute. We can change it this way:

//example for match()
function count1(str,char){
  return (str.match(new RegExp(char,"g"))||[]).length
}
console.log(count1("aaaaa","a"))  //output: 5
console.log(count1("aaaaa","b"))  //output: 0

This will avoid the errors.